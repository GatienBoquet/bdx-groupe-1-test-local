
![Logo](https://github.blog/wp-content/uploads/2019/08/DL-V2-LinkedIn_FB.png?fit=1200%2C630)


## ğŸ“ Introduction

Nous avons dÃ©cidÃ© de protÃ©ger la brache main du projet github. 
Afin de rÃ©duire la redondance et de faciliter la pipeline CICD.
L'idÃ©e est simple : La branche main est prÃ´tÃ©gÃ©e.

1. Nous avons besoin de faire un pull request avant de mergÃ© sur la 'main'.
2. 2 personnes doivent review la pull request avant de pouvoir mergÃ© sur la 'main'.

Cela assurer une qualitÃ© de code et de fonctionnement du projet.

Aussi, nous pouvons ajouter une condition sur les tests de la pipeline CI.
En effet, sur chaque pull request et sur chaque commit de cette pull request, la pipeline CI nous permets de vÃ©rifier le bon fonctionnement du projet.

Avec ces trois conditions, nous nous assurons un bon fonctionnement du projet avant de merger sur la main branche.
La branche main reprÃ©sente donc pour nous l'environnement  staging et prod.

Le concept de CICD est respectÃ© et permet un cycle de dÃ©veloppement de l'application rapide et concis.

![Dev Ops](https://3.bp.blogspot.com/-Ecj2B__l7nA/XH-X3IULJYI/AAAAAAAABjQ/EtAL40fOPbk_G_t0GfKniuSjZB-lR0HWACLcBGAs/s640/traditional-devops.png)
## ğŸ§® Les fonctionnallitÃ©s de la pipeline
Nous avons 3 pipeline, Dev, Staging puis Prod

### â›¹ï¸â€â™‚ï¸ La pipeline CI Dev, Ã©tape par Ã©tape

- On rÃ©cupÃ¨re le contenu de notre repository
- On installe Node.JS 
- On vÃ©rifie le contenu du cache
- On installe les dÃ©pendances
- On lance le serveur Node.JS
- On lance les tests unitaires
Puis si cela fonctionne on passe Ã  la sucuritÃ© :
- On lance snyk vÃ©rifiÃ© s'il y a d'Ã©ventuelles vulnÃ©rabilitÃ©s
- On upload le rÃ©sultat sur CodeScanning, le service disponible sur GitHub
S'il y a aucune vulnerabilitÃ©s, on passe Ã  l'Ã©tape du Linter
- On rÃ©cupÃ¨re le contenu du repository.
- On vÃ©rifie le repo avec super-linter.
Puis un passe Ã  l'Ã©tape du build de l'image
- On build l'image avec BuildX
- On la push sur le package repository associÃ© Ã  notre rÃ©po github.
Puis pour finir, la derniÃ¨re Ã©tape consiste Ã  notifier du rÃ©sultat sur slack.

Une fois les test finit, on regarde ensemble pour mÃ©rger la pull request.
Si la pull request est mergÃ©, la pipepine staging s'enclenche.

### ğŸ¤¾â€â™‚ï¸ La pipeline CD Dev

- On rÃ©cupÃ¨re le package sur le repo github 
- On le deploy sur heroku
- On fait un healthcheck pour s'assurer du bon fonctionnement
- On envoie une notification sur Slack

### ğŸŒ  La pipeline CI et CD Staging et Prod

- TODO
- add moniroting


## ğŸ”¬ Installation pipeline

- TÃ©lÃ©charger les fichiers ci.yml et cd.yml 
- Assurez-vous d'avoir les bonnes variables d'environements
- Avoir un compte AWS et Heroku

### Pipeline Prod
![Pipeline prod](https://i.imgur.com/saUIvmh.png)


![Pipeline prod](https://i.imgur.com/e07mQfIl.png)


## ğŸ–¥ï¸ Le stack du site web

**Client:** HTML, CSS

**Serveur:** Node, Express


## â™¾ï¸ Le stack de la pipeline

**Conteneurisation:** Docker

**HÃ©bergement:** Heroku et AWS

**SÃ©curitÃ©:** Snik

**Linter:** Super Linter

**Registre de container:** GitHub Registry container

**WebHook:** Slack
## ğŸ”€ Diagramme sÃ©quentielle


```mermaid
sequenceDiagram
    autonumber
    actor Developpeur
    participant Repository
    participant CI 
    participant CD
    participant Environements
    participant Slack
    Developpeur->>+Repository: Commit Code 
    loop Every merge request
        Repository->>+CI: TÃ©lÃ©charge le repo
        CI->>+CI: Test Unitaires
        CI->>+CI: Test SÃ©curitÃ©
        CI-->>+Repository: Upload du rÃ©sultat sÃ©curitÃ© sur CodeScanning
        CI->>+CI: Super Linter
        CI->>+CI: Build de l'image
        CI->>+Slack: Notification de statut du build
        CI->>+Repository: Upload de l'image sur le repo GitHub
        Repository->>+CD: TÃ©lÃ©chargment de la derniÃ¨re image 
        CD->>+Environements: DÃ©ploiement
        Note right of Environements: Heroku (Dev)
        CD-->>CD: Healthcheck 
        CD->>+Slack: Notification de statut du dÃ©ploiement
        CD->>Repository: Feedback des tests
    end
```

## ğŸª› Pour installer le projet

Vous pouvrz installer le projet avec le gestionnaire de paquage npm.
Vous avez besoin d'un serveur Node.JS avec la version 14.16

```bash
  npm install bdx-groupe-1
  cd my-project
```

- [ ]  Avoir un serveur Node.JS
- [ ]  Avoir les variables d'environements en place
- [ ]  Avoir un compte Heroku et AWS
## ğŸ“ Auteurs

- [@arnaudtron](https://www.github.com/arnaudtron)
- [@karim](https://www.github.com/styldown)
- [@gatienboquet](https://www.github.com/gatienboquet)
## ğŸ”” Badges

Add badges from somewhere like: [shields.io](https://shields.io/)

[![MIT License](https://img.shields.io/apm/l/atomic-design-ui.svg?)](https://github.com/tterb/atomic-design-ui/blob/master/LICENSEs)
[![GPLv3 License](https://img.shields.io/badge/License-GPL%20v3-yellow.svg)](https://opensource.org/licenses/)
[![AGPL License](https://img.shields.io/badge/license-AGPL-blue.svg)](http://www.gnu.org/licenses/agpl-3.0)

## ğŸ” Les variables d'environements 

Pour pouvoir assurer le fonctionnement  de la pipeline CICD, vous avez besoin de dÃ©finir certaines variables. 
Ces variables sont confidentielles, assurez-vous de ne pas les divulguer publiquement.

`HEROKU_API_KEY` : La clÃ© API pour dÃ©ployer sur Heroku

`SNYK_TOKEN` : La clÃ© pour l'analyse du code avec Snyk

`SLACK_WEBHOOK_URL` : Le lien du webhook Slack

`AWS_PRIVATE_KEY` : La clÃ© privÃ© du serveur EC2 d'AWS

`HOSTNAME` : Le nom d'hote du serveur EC2 d'AWS

`USER_NAME`: L'username du serveur EC2 d'AWS
## ğŸ“š LeÃ§ons apprises

What did you learn while building this project? What challenges did you face and how did you overcome them?


## ğŸ‘ Remerciements

 - [Ulrich MONJI](https://github.com/ulrichmonji)
 - [Awesome README](https://github.com/matiassingers/awesome-readme)
 - [How to write a Good readme](https://bulldogjob.com/news/449-how-to-write-a-good-readme-for-your-github-project)


## ğŸ“œ License

[MIT](https://choosealicense.com/licenses/mit/)


## ğŸ’¡ AmÃ©liorations possibles

